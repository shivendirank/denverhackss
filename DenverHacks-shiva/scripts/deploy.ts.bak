import hre from "hardhat";
import { writeFileSync, mkdirSync } from "fs";
import { resolve } from "path";
import { defineChain } from "viem";

// Custom chains not in viem's built-in list
const kiteTestnet = defineChain({
  id: 2368,
  name: "Kite AI Testnet",
  nativeCurrency: { name: "KITE", symbol: "KITE", decimals: 18 },
  rpcUrls: { default: { http: [process.env.KITE_RPC_URL ?? "https://rpc-testnet.gokite.ai"] } },
});

const zgTestnet = defineChain({
  id: 16602,
  name: "0G Galileo Testnet",
  nativeCurrency: { name: "0G", symbol: "OG", decimals: 18 },
  rpcUrls: { default: { http: [process.env.ZG_RPC_URL ?? "https://evmrpc-testnet.0g.ai"] } },
});

const customChains: Record<string, ReturnType<typeof defineChain>> = {
  kiteTestnet,
  zgTestnet,
};

interface DeploymentConfig {
  [key: string]: {
    contracts: string[];
    relayerRequired: boolean;
  };
}

const deploymentConfig: DeploymentConfig = {
  baseSepolia: {
    contracts: ["ToolRegistry", "Escrow", "UsageLog"],
    relayerRequired: true,
  },
  kiteTestnet: {
    contracts: ["ToolRegistry", "Escrow"],
    relayerRequired: true,
  },
  zgTestnet: {
    contracts: ["AgentNFT"],
    relayerRequired: true,
  },
};

async function main() {
  const networkName = hre.network.name;
  const config = deploymentConfig[networkName];

  if (!config) {
    throw new Error(`Unsupported network: ${networkName}`);
  }

  console.log(`\nðŸ“¦ Deploying to ${networkName}...`);

  const deployments: { [key: string]: string } = {
    network: networkName,
    deployedAt: new Date().toISOString(),
  };

  // Get relayer address from signer
  const chain = customChains[networkName];
  const clientOpts = chain ? { chain } : {};
  const [signer] = await hre.viem.getWalletClients(clientOpts as any);
  const relayerAddress = signer.account?.address;

  if (!relayerAddress) {
    throw new Error("Cannot determine relayer address from signer");
  }

  console.log(`ðŸ” Relayer address: ${relayerAddress}`);

  // Deploy ToolRegistry
  if (config.contracts.includes("ToolRegistry")) {
    console.log("\nðŸ“ Deploying ToolRegistry...");
    const toolRegistry = await hre.viem.deployContract("ToolRegistry", [], clientOpts as any);
    console.log(`âœ… ToolRegistry deployed at: ${toolRegistry.address}`);
    deployments.toolRegistry = toolRegistry.address;
  }

  // Deploy Escrow
  if (config.contracts.includes("Escrow")) {
    console.log("\nðŸ’° Deploying Escrow...");
    const escrow = await hre.viem.deployContract("Escrow", [relayerAddress], clientOpts as any);
    console.log(`âœ… Escrow deployed at: ${escrow.address}`);
    deployments.escrow = escrow.address;

    // Update relayer if needed
    console.log(`ðŸ“Œ Escrow relayer set to: ${relayerAddress}`);
  }

  // Deploy UsageLog
  if (config.contracts.includes("UsageLog")) {
    console.log("\nðŸ“Š Deploying UsageLog...");
    const usageLog = await hre.viem.deployContract("UsageLog", [relayerAddress], clientOpts as any);
    console.log(`âœ… UsageLog deployed at: ${usageLog.address}`);
    deployments.usageLog = usageLog.address;
  }

  // Deploy AgentNFT
  if (config.contracts.includes("AgentNFT")) {
    console.log("\nðŸŽ­ Deploying AgentNFT...");
    const agentNFT = await hre.viem.deployContract("AgentNFT", [relayerAddress], clientOpts as any);
    console.log(`âœ… AgentNFT deployed at: ${agentNFT.address}`);
    deployments.agentNFT = agentNFT.address;
  }

  // Write deployments to file
  const deploymentsDir = resolve("deployments");
  mkdirSync(deploymentsDir, { recursive: true });

  const deploymentFile = resolve(
    deploymentsDir,
    `${networkName}.json`
  );
  writeFileSync(deploymentFile, JSON.stringify(deployments, null, 2));

  console.log(`\nðŸ“ Deployments saved to: ${deploymentFile}`);
  console.log("\nâœ¨ Deployment complete!");
  console.log("\nDeployment Summary:");
  console.log(JSON.stringify(deployments, null, 2));
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

